#!/usr/bin/perl


use 5.006;
use feature 'unicode_strings';
use strict;
use warnings;

use Carp qw();
use File::Basename qw();
use File::Spec;

use Data::Dumper;

sub usage {
	return <<USAGE;
usage:
$0 data ../lib/ZXCVBN/FrequencyLists.pm

generates FrequencyLists.pm (zxcvbn's ranked dictionary file) from word frequency data.
data dir should contain frequency counts, as generated by the scripts.

DICTIONARIES controls which frequency data will be included and at maximum how many tokens
per dictionary.

If a token appears in multiple frequency lists, it will only appear once in emitted .coffee file,
in the dictionary where it has lowest rank.

Short tokens, if rare, are also filtered out. If a token has higher rank than 10**(token.length),
it will be excluded because a bruteforce match would have given it a lower guess score.

A warning will be printed if DICTIONARIES contains a dictionary name that doesn't appear in
passed data dir, or vice-versa.
USAGE
}

# maps dict name to num words. None value means "include all words"
my %DICTIONARIES = (
	'us_tv_and_film' => 30000,
	'english_wikipedia' => 30000,
	'passwords' => 30000,
	'surnames' => 10000,
	'male_names' => undef,
	'female_names' => undef
);


=head2 parse_frequency_lists
returns {list_name => {token => rank}}, as tokens and ranks occur in each file.
=cut
sub parse_frequency_lists($) {
	my($data_dir) = @_;
	
	my %freq_lists = ();
	if(opendir(my $D,$data_dir)) {
		while(my $filename=readdir($D)) {
			# Skipping hidden filenames (and directories)
			next  if(substr($filename,0,1) eq '.');
			
			my($freq_list_name, undef, $ext) = File::Basename::fileparse($filename,qr/\..*$/);
			unless(exists($DICTIONARIES{$freq_list_name})) {
				print "Warning: $freq_list_name appears in $data_dir directory but not in DICTIONARY settings. Excluding.\n";
				next;
			}
			
			my %token_to_rank = ();
			
			my $fullfilename = File::Spec->catfile($data_dir,$filename);
			if(open(my $F,'<:encoding(UTF-8)',$fullfilename)) {
				my $rank = 0;
				while(my $line=<$F>) {
					chomp($line);
					$rank++;
					my($token,undef) = split(/\s/,$line,2);
					$token_to_rank{$token} = $rank;
				}
				
				close($F);
			} else {
				Carp::croak("Error while opening data file $fullfilename. Message: $!");
			}
			$freq_lists{$freq_list_name} = \%token_to_rank;
		}
		
		closedir($D);
	} else {
		Carp::croak("Error while opening data directory $data_dir. Message: $!");
	}
	
	foreach my $freq_list_name (keys(%DICTIONARIES)) {
		unless(exists($freq_lists{$freq_list_name})) {
			print "Warning: $freq_list_name appears in DICTIONARY settings but not in $data_dir directory. Excluding.\n";
		}
	}
	
	return \%freq_lists;
}

sub is_rare_and_short($$) {
	my($token,$rank) = @_;
	
	return $rank >= (10 ** length($token));
}

sub has_comma_or_double_quote($) {
	my($token) = @_;
	# hax, switch to csv or similar if this excludes too much.
	# simple comma joining has the advantage of being easy to process
	# client-side w/o needing a lib, and so far this only excludes a few
	# very high-rank tokens eg 'ps8,000' at rank 74868 from wikipedia list.
	return index($token,',') >=0 || index($token,'"') >=0;
}

=head2 filter_frequency_lists
    filters frequency data according to:
        - filter out short tokens if they are too rare.
        - filter out tokens if they already appear in another dict
          at lower rank.
        - cut off final freq_list at limits set in DICTIONARIES, if any.
=cut
sub filter_frequency_lists(\%) {
	my($p_freq_lists) = @_;
	
	my %filtered_token_and_rank = ();	# maps {name => [[token, rank], ...]}
	my %token_count = ();	# maps freq list name: current token count.
	foreach my $name (keys(%{$p_freq_lists})) {
		$filtered_token_and_rank{$name} = [];
		$token_count{$name} = 0;
	}
	my %minimum_rank = ();	# maps token -> lowest token rank across all freq lists
	my %minimum_name = ();	# maps token -> freq list name with lowest token rank
	while(my($name,$p_token_to_rank) = each(%{$p_freq_lists})) {
		while(my($token,$rank) = each(%{$p_token_to_rank})) {
			unless(exists($minimum_rank{$token})) {
				Carp::croak()  if(exists($minimum_name{$token}));
				$minimum_rank{$token} = $rank;
				$minimum_name{$token} = $name;
			} else {
				Carp::croak()  unless(exists($minimum_name{$token}));
				Carp::croak("same token '$token' occurs multiple times in $name -> ".$minimum_name{$token})  if($minimum_name{$token} eq $name);
				my $min_rank = $minimum_rank{$token};
				if($rank < $min_rank) {
					$minimum_rank{$token} = $rank;
					$minimum_name{$token} = $name;
				}
			}
		}
	}

	while(my($name,$p_token_to_rank) = each(%{$p_freq_lists})) {
		while(my($token,$rank) = each(%{$p_token_to_rank})) {
			if($minimum_name{$token} ne $name) {
				next;
			}
			if(is_rare_and_short($token,$rank) ||  has_comma_or_double_quote($token)) {
				next;
			}
			push(@{$filtered_token_and_rank{$name}},[$token,$rank]);
			$token_count{$name}++;
		}
	}
	
	my %result = ();
	while(my($name,$token_rank_pairs) = each(%filtered_token_and_rank)) {
		my @sorted_token_rank_pairs = sort { $a->[1] <=> $b->[1] } @{$token_rank_pairs};
		my $cutoff_limit = $DICTIONARIES{$name};
		if($cutoff_limit && scalar(@sorted_token_rank_pairs) > $cutoff_limit) {
			splice(@sorted_token_rank_pairs,$cutoff_limit);
		}
		$result{$name} = [ map { $_->[0] } @sorted_token_rank_pairs ];	# discard rank post-sort
	}
	
	return \%result;
}

sub to_kv(\@$) {
	my($lst,$lst_name) = @_;
	
	
}

sub main() {
	if(scalar(@ARGV)!=2) {
		print usage();
		exit 1;
	}

	my($data_dir,$output_file) = @ARGV;

	if(open(my $f,'>:encoding(UTF-8)',$output_file)) {
		my $p_unfiltered_freq_lists = parse_frequency_lists($data_dir);
		my $p_freq_lists = filter_frequency_lists(%{$p_unfiltered_freq_lists});
		
		$Data::Dumper::Terse = 1;
		$Data::Dumper::Sortkeys = 1;
		my $gline = Data::Dumper->Dump([$p_freq_lists]);
		$gline = substr($gline,1,-2);
		print $f <<'EOF';
#!/usr/bin/perl

use 5.006;
use feature 'unicode_strings';
use strict;
use warnings;

package ZXCVBN::FrequencyLists;

EOF
	print $f <<EOF;
# generated by $0

our %FREQUENCY_LISTS = ($gline);

1;
EOF
		close($f);
		exit 0;
	} else {
		Carp::croak("Unable to create output file $output_file. Reason: $!");
	}
}

main();